---
marp: true
theme: default
paginate: true
header: "XP研修 - エクストリーム・プログラミング実践"
style: |
  section {
    font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Noto Sans JP', sans-serif;
    font-size: 22px;
    padding: 40px 50px 30px 50px;
    line-height: 1.5;
  }
  h1 { font-size: 1.6em; margin-bottom: 0.3em; }
  h2 { font-size: 1.3em; margin-bottom: 0.2em; }
  h3 { font-size: 1.1em; margin-bottom: 0.2em; }
  section.title {
    text-align: center;
    justify-content: center;
  }
  section.title h1 {
    font-size: 2.2em;
  }
  table {
    font-size: 0.85em;
  }
  code {
    font-size: 0.9em;
  }
  pre { margin: 0.4em 0; }
  ul, ol { margin: 0.3em 0; }
  p { margin: 0.3em 0; }
  blockquote { margin: 0.3em 0; }
---

<!-- _class: title -->
<!-- _paginate: false -->
<!-- _header: "" -->

# XP研修
## エクストリーム・プログラミング実践ワークショップ

**対象**: ジュニア開発者
**前提**: Java基礎、JUnit基礎
**環境**: Java 17 / Maven / JUnit 5

---

# アジェンダ

| #   | 内容                                       | 形式       |
| --- | ------------------------------------------ | ---------- |
| 1   | XPの概要                                   | 講義       |
| 2   | XPの5つの価値                              | 講義       |
| 3   | XPの原則                                   | 講義       |
| 4   | 環境セットアップ                           | ハンズオン |
| 5   | 演習1: FizzBuzz / TDD                      | 演習       |
| 6   | 演習2: Calculator / ペアプログラミング     | 演習       |
| 7   | 演習3: StringCalculator / リファクタリング | 演習       |
| 8   | 演習4: BowlingGame / 継続的統合            | 演習       |
| 9   | 振り返りとディスカッション                 | 議論       |
| 10  | まとめ                                     | 講義       |

---

<!-- _class: title -->

# 第1部
## XPの概要

---

# XPとは何か

**エクストリーム・プログラミング (XP)** は、Kent Beck が1990年代に提唱したアジャイル開発手法

### 背景
- ウォーターフォール型開発の限界（変更に弱い、フィードバックが遅い）
- 「うまくいくプラクティス」を**極端に（Extreme）** 実践する
- 1999年 "Extreme Programming Explained" 初版刊行

### 核心的なアイデア

| 良いプラクティス | 極限まで推進 | XPのプラクティス |
|---|---|---|
| コードレビュー | → 常にレビュー | **ペアプログラミング** |
| テスト | → 常にテスト | **テスト駆動開発** |
| 統合 | → 常に統合 | **継続的統合** |

---

# XPの全体像

|             階層             | 内容                                                           | 役割                   |
| :--------------------------: | -------------------------------------------------------------- | ---------------------- |
|      **価値 (Values)**       | コミュニケーション / シンプルさ / フィードバック / 勇気 / 尊敬 | 方向性を示す           |
|            ↓ 導く            |                                                                |                        |
|    **原則 (Principles)**     | 小さなステップ / 変更の受け入れ / 品質への責任 / 多様性        | 判断基準を提供する     |
|           ↓ 具体化           |                                                                |                        |
| **プラクティス (Practices)** | TDD / ペアプログラミング / CI / リファクタリング               | 具体的な行動を定義する |

**価値**が方向性を示し、**原則**が判断基準を提供し、**プラクティス**が具体的な行動を定義する

---

# XPと他のアジャイル手法との関係

|       | **Scrum**        | **Kanban**       | **XP**               |
| ----- | ---------------- | ---------------- | -------------------- |
| 焦点  | プロジェクト管理 | ワークフロー管理 | **技術プラクティス** |
| 特徴1 | 役割定義         | 可視化           | TDD                  |
| 特徴2 | スプリント       | WIP制限          | ペアプログラミング   |
| 特徴3 | イベント         | フロー           | 継続的統合           |

- 3つの手法は**組み合わせて使うことが多い**
- **XP**は技術的なプラクティスに焦点 ← **本研修のテーマ**

---

# XPが目指すもの

### ソフトウェア開発の「変更コスト曲線」を変える

**従来の考え方**: 開発後期の変更コストは指数関数的に増大する
**XPの考え方**: 適切なプラクティスで変更コストを低く保てる

### XPが実現すること
- 変化する要件に柔軟に対応
- 高品質なコードを継続的に維持
- チーム内の信頼と協力関係の構築
- 早期かつ頻繁なフィードバック

---

<!-- _class: title -->

# 第2部
## XPの5つの価値

---

# 5つの価値の全体像

|   #   | 価値                   | 英語          | キーワード                   |
| :---: | ---------------------- | ------------- | ---------------------------- |
|   1   | **コミュニケーション** | Communication | 対話、共有、透明性           |
|   2   | **シンプルさ**         | Simplicity    | YAGNI、最小限、明確さ        |
|   3   | **フィードバック**     | Feedback      | テスト、CI、レビュー         |
|   4   | **勇気**               | Courage       | リファクタリング、正直、挑戦 |
|   5   | **尊敬**               | Respect       | 傾聴、建設的議論、多様性     |

5つの価値は相互に支え合い、XPの行動原理を形成する

---

# 価値1: コミュニケーション (Communication)

### 定義
チームメンバー全員が必要な情報を共有し、効果的に対話すること

### なぜ重要か
- ソフトウェア開発の問題の多くは**コミュニケーション不足**に起因する
- 暗黙知を形式知にする
- 認識のズレを早期に解消する

### 実践例
- **ペアプログラミング**: 常に対話しながらコードを書く
- **スタンドアップミーティング**: 毎日の状況共有
- **オンサイト顧客**: 顧客と直接対話

> 演習2（Calculator）でペアプログラミングを通じて実践します

---

# 価値2: シンプルさ (Simplicity)

### 定義
今必要なことだけを行い、余分な複雑さを避けること

### YAGNI原則
> **Y**ou **A**ren't **G**onna **N**eed **I**t
> 「それは必要にならない」

### 実践例
- 最小限の設計で始める
- 将来の要件を推測して実装しない
- 複雑さが増したらリファクタリングで解消する

### アンチパターン
- 使われない設定オプションの追加
- 現在1つしかない実装のための抽象化
- 不要なデザインパターンの適用

---

# 価値3: フィードバック (Feedback)

### 定義
行動の結果を素早く知り、それに基づいて改善すること

### フィードバックの3つのレベル

| レベル         | 手段                         | サイクル |
| -------------- | ---------------------------- | -------- |
| コードレベル   | ユニットテスト、静的解析     | 秒〜分   |
| チームレベル   | CI、ペアプロ、コードレビュー | 分〜時間 |
| ビジネスレベル | デモ、ユーザーテスト         | 日〜週   |

### 核心
- フィードバックループは**短いほど良い**
- テストは最速のフィードバックメカニズム
- 失敗を早く知ることで修正コストを下げる

---

# 価値4: 勇気 (Courage)

### 定義
正しいことを行う勇気を持つこと。恐れずに変更し、問題に向き合うこと

### 勇気が必要な場面
- 動いているコードを**リファクタリング**する
- 問題を見つけたら**正直に報告**する
- 設計を**大幅に変更**する決断をする
- 「分かりません」と**正直に言う**

### 勇気を支えるもの
- **テストがあるから**安全にリファクタリングできる
- **ペアがいるから**困難な問題にも挑戦できる
- **小さなステップだから**失敗しても戻せる

> 勇気は無謀とは違う。テストとチームに支えられた勇気

---

# 価値5: 尊敬 (Respect)

### 定義
チームの全員がお互いの貢献を認め、尊重すること

### 尊敬が意味すること
- すべてのチームメンバーには**固有の価値**がある
- 異なる意見や視点を**歓迎**する
- 批判は**人ではなくコード**に向ける
- 間違いは**学習の機会**として捉える

### 具体的な行動
- 相手の意見を最後まで聞く
- 建設的な提案をする（「こうしたらどう？」）
- 良いアイデアは積極的に取り入れる
- 感謝を言葉にする

> すべての演習を通じて、チームメンバーへの尊敬を実践します

---

<!-- _class: title -->

# 第3部
## XPの原則

---

# 基本原則

### 小さなステップ (Baby Steps)
- 変更は**小さく分割**して進める
- 一度に多くのことをやろうとしない
- 各ステップで**動作確認**する

### 変更の受け入れ (Embracing Change)
- 要件の変更は**歓迎すべきもの**
- 変更に強い設計を心がける
- 柔軟に適応する姿勢を持つ

### 品質への責任 (Quality Work)
- 高い品質基準を**妥協しない**
- 技術的負債を放置しない
- テストカバレッジを維持する

---

# 実践原則

### 漸進的変更 (Incremental Change)
- 大きな変更を一度にやらない
- 段階的に改善を重ねる

### 適応 (Adaptation)
- 計画に固執しない
- 状況の変化に応じて方向を修正する

### 多様性 (Diversity)
- 異なる視点やスキルを活かす
- 多角的な問題解決につなげる

### 責任の受け入れ (Accepted Responsibility)
- 自ら責任を引き受ける
- 押し付けるのではなく、自発的に担う

---

# 原則とプラクティスの対応

| 原則           | 対応するプラクティス             | 本研修の演習            |
| -------------- | -------------------------------- | ----------------------- |
| 小さなステップ | TDD (Red-Green-Refactor)         | 演習1: FizzBuzz         |
| 変更の受け入れ | リファクタリング、Small Releases | 演習3: StringCalculator |
| 品質への責任   | テスト、CI                       | 演習4: BowlingGame      |
| 多様性         | ペアプログラミング               | 演習2: Calculator       |
| 漸進的変更     | 段階的な機能追加                 | 演習3: StringCalculator |

---

<!-- _class: title -->

# 第4部
## 環境セットアップ

---

# 必要な環境

### 必須ソフトウェア
| ソフトウェア | バージョン | 用途             |
| ------------ | ---------- | ---------------- |
| Java (JDK)   | 17 以上    | コンパイル・実行 |
| Maven        | 3.8 以上   | ビルド・テスト   |
| Git          | 最新版     | バージョン管理   |
| IDE          | 任意       | コード編集       |

### 動作確認

```bash
java --version      # Java 17 以上であること
mvn --version       # Maven 3.8 以上であること
git --version       # Gitが使えること
```

---

# プロジェクト構成

```
xp-training-java/
├── src/main/java/com/company/xp/
│   ├── FizzBuzz.java           # 演習1
│   ├── Calculator.java         # 演習2
│   ├── StringCalculator.java   # 演習3
│   ├── BowlingGame.java        # 演習4
│   └── XPReflection.java       # 振り返りガイド
├── src/test/java/com/company/xp/
│   ├── FizzBuzzTest.java       # 演習1テスト
│   ├── CalculatorTest.java     # 演習2テスト
│   ├── StringCalculatorTest.java
│   ├── BowlingGameTest.java    # 演習4テスト
│   └── XPAssessmentTest.java   # 理解度確認
└── pom.xml
```

---

# よく使うコマンド

```bash
mvn test                          # 全テスト実行
mvn test -Dtest=FizzBuzzTest      # 特定テストクラスの実行
mvn test jacoco:report            # カバレッジレポート生成
```

### 個別テストメソッドの実行
```bash
mvn test -Dtest=FizzBuzzTest#shouldReturnNumberAsString
```

---

<!-- _class: title -->

# 第5部
## 演習1: FizzBuzz / TDD

---

# 演習1: FizzBuzz - 課題説明

### 要件
- 数字を受け取り、文字列を返す
- **3で割り切れる** → `"Fizz"`
- **5で割り切れる** → `"Buzz"`
- **3と5の両方で割り切れる** → `"FizzBuzz"`
- **それ以外** → 数字をそのまま文字列で返す

### 対象ファイル
- `FizzBuzz.java` - 実装クラス
- `FizzBuzzTest.java` - テストクラス

### XPフォーカス
- **Test-First Development**: テストを先に書く
- **Simple Design**: 最小限の実装
- **Refactoring**: 実装後の改善

---

# TDDサイクル: Red-Green-Refactor

```
   RED ---------> GREEN ---------> REFACTOR
    |                                  |
    +----------------------------------+
```

| ステップ | やること | やらないこと |
|---------|---------|------------|
| **Red** | 1つの失敗するテストを書く | 複数のテストを一度に書く |
| **Green** | テストが通る最小限のコードを書く | きれいなコードを書こうとする |
| **Refactor** | 重複を除去し、設計を改善する | 新しい機能を追加する |

---

# TDD実践例: 最初のテスト

### Step 1: RED - 失敗するテストを書く

```java
@Test
@DisplayName("通常の数字はそのまま文字列で返す")
void shouldReturnNumberAsString() {
    assertEquals("1", fizzBuzz.convert(1));
}
```

```bash
mvn test -Dtest=FizzBuzzTest#shouldReturnNumberAsString
```

→ `UnsupportedOperationException` で **RED（失敗）**

---

# TDD実践例: 最小限の実装

### Step 2: GREEN - テストが通る最小限のコードを書く

```java
public String convert(int number) {
    return String.valueOf(number);
}
```

```bash
mvn test -Dtest=FizzBuzzTest#shouldReturnNumberAsString
```

→ テスト **GREEN（成功）**

### Step 3: REFACTOR
- この段階ではリファクタリングの必要なし
- 次のテストへ進む

---

# 演習1: 進め方

### テストの実装順序（推奨）

| # | テスト | 期待結果 |
|---|--------|---------|
| 1 | 通常の数字 | `convert(1)` → `"1"` |
| 2 | Fizz | `convert(3)` → `"Fizz"` |
| 3 | Buzz | `convert(5)` → `"Buzz"` |
| 4 | FizzBuzz | `convert(15)` → `"FizzBuzz"` |
| 5 | 連続生成 | `generateSequence(1, 3)` → 配列 |

### ルール
- 必ず**テストを先に書く**
- 各テストは**1つのことだけ**を確認する
- テストが通ったら**リファクタリング**を検討する

---

# 演習1: 振り返りのポイント

### 体験した価値
- **シンプルさ**: 最小限のコードで実装できたか
- **フィードバック**: テストによる即座の確認を体験できたか
- **勇気**: リファクタリングを恐れずに実行できたか

### 振り返り質問
- テストを先に書くことで、何が変わりましたか？
- 「最小限の実装」とは具体的にどういうことでしたか？
- Red-Green-Refactorのリズムはどうでしたか？

---

<!-- _class: title -->

# 第6部
## 演習2: Calculator / ペアプログラミング

---

# 演習2: Calculator - 課題説明

### 要件
- 基本的な四則演算（加算、減算、乗算、除算）
- 0除算時のエラーハンドリング（`ArithmeticException`）
- メモリ機能（値の保存・呼び出し・クリア）

### 対象ファイル
- `Calculator.java` / `CalculatorTest.java`

### メソッド一覧
| メソッド | 機能 |
|---------|------|
| `add`, `subtract`, `multiply` | 加算・減算・乗算 |
| `divide(a, b)` | 除算（0除算チェック） |
| `saveToMemory` / `recallFromMemory` | メモリ保存・呼出 |
| `clearMemory()` | メモリクリア |

---

# ペアプログラミングの基本

### 2つのロール

|      | **ドライバー (Driver)**     | **ナビゲーター (Navigator)** |
| ---- | --------------------------- | ---------------------------- |
| 役割 | キーボードを操作する        | 全体を俯瞰して考える         |
| 担当 | コードを書く / テストを実行 | 設計を考える / ミスを指摘    |
| 視点 | 現在の実装に集中            | 次の手順を提案               |

### ルール
- **5〜10分間隔**でロールを交代する
- 常に**声に出して考える**（Think Aloud）
- 相手の意見を**尊重**する
- 分からないことは**すぐに質問**する

---

# ペアプログラミングのルール

| | **ドライバーの責任** | **ナビゲーターの責任** |
|---|---|---|
| 1 | コードをタイプする | 全体の方向性を考える |
| 2 | 現在の実装に集中する | タイプミスやバグを見つける |
| 3 | ナビゲーターの指示を受けて実装する | 次のステップを提案する |

### 心がけ
- 常に**声に出して考える**（Think Aloud）
- 相手の意見を**尊重**する
- 分からないことは**すぐに質問**する

---

# 演習2: 進め方

### ステップ
1. ペアを組む → 2. ロールを決める → 3. テスト実装 → 4. 交代 → 5. リファクタリング

### 実装順序（推奨）- テストごとにロール交代

| # | テスト | ロール交代 |
|---|--------|----------|
| 1 | 足し算 | ペアA: ドライバー |
| 2 | 引き算 | ペアB: ドライバー |
| 3 | 掛け算 | ペアA: ドライバー |
| 4 | 割り算 | ペアB: ドライバー |
| 5 | 0除算の例外 | ペアA: ドライバー |
| 6 | メモリ機能 | ペアB: ドライバー |
| 7 | メモリクリア | ペアA: ドライバー |

---

# テスト例: 0除算の例外テスト

### テストコード

```java
@Test
@DisplayName("0除算時に適切な例外が発生する")
void shouldThrowExceptionWhenDividingByZero() {
    assertThrows(ArithmeticException.class,
        () -> calculator.divide(5.0, 0.0));
}
```

### 実装コード

```java
public double divide(double a, double b) {
    if (b == 0) {
        throw new ArithmeticException("Division by zero");
    }
    return a / b;
}
```

---

# 演習2: 振り返りのポイント

### 体験した価値
- **コミュニケーション**: 効果的な対話ができたか
- **尊敬**: パートナーを尊重できたか
- **勇気**: 質問や提案を恐れずにできたか

### 振り返り質問
- ドライバーとナビゲーター、どちらがやりやすかったですか？
- ペアプログラミングで発見できた問題はありましたか？
- 1人で書くときと比べて、何が違いましたか？
- コミュニケーションで工夫した点は？

---

<!-- _class: title -->

# 第7部
## 演習3: StringCalculator / リファクタリング

---

# 演習3: StringCalculator - 課題説明

### 要件
- 文字列形式の数字を受け取り、合計を返す
- カンマ・改行での区切りをサポート
- カスタム区切り文字をサポート
- 負の数は例外を投げる
- 1000以上の数字は無視する

### 対象ファイル
- `StringCalculator.java` - 実装クラス
- `StringCalculatorTest.java` - テストクラス

### XPフォーカス
- **Refactoring**: 段階的にコードを改善する
- **Small Releases**: 機能を段階的に追加する
- **Simple Design**: 各段階でシンプルさを維持する

---

# 7段階の実装ステップ

| Step | 要件                     | 入力例          | 期待出力 |
| ---- | ------------------------ | --------------- | -------- |
| 1    | 空文字列は0を返す        | `""`            | `0`      |
| 2    | 1つの数字を処理          | `"5"`           | `5`      |
| 3    | カンマ区切りの複数の数字 | `"1,2,3"`       | `6`      |
| 4    | 改行文字も区切り文字     | `"1\n2,3"`      | `6`      |
| 5    | カスタム区切り文字       | `"//;\n1;2"`    | `3`      |
| 6    | 負の数は例外を投げる     | `"1,-2,3"`      | 例外     |
| 7    | 1000以上は無視           | `"1000,1001,1"` | `1001`   |

### ポイント
- **1ステップずつ**実装する（先のステップを見越した設計をしない）
- 各ステップ完了後に**リファクタリング**を検討する
- 既存のテストが**常にグリーン**であることを確認する

---

# リファクタリングの原則

### リファクタリングとは
> 外部から見た振る舞いを変えずに、内部構造を改善すること

### タイミング
- テストが**グリーン**のときだけリファクタリングする
- 新機能追加の前後に検討する

### よくあるリファクタリング
| パターン           | 内容                               |
| ------------------ | ---------------------------------- |
| **メソッド抽出**   | 長いメソッドを小さなメソッドに分割 |
| **変数名の改善**   | 意図が伝わる名前に変更             |
| **重複の除去**     | 同じ処理をメソッドにまとめる       |
| **条件分岐の整理** | ネストを減らし、読みやすくする     |

### 安全にリファクタリングする鍵
> **テストがあるからこそ、安心してコードを変更できる**

---

# Small Releasesの考え方

各ステップで常に **「動くソフトウェア」** が存在する:

**Step 1** → **Step 2** → **Step 3** → **Step 4** → **Step 5** → **Step 6** → **Step 7**

| Step | 機能           | 状態  |
| ---- | -------------- | ----- |
| 1    | 空文字列 = 0   | 動く! |
| 2    | 1つの数字      | 動く! |
| 3    | カンマ区切り   | 動く! |
| 4    | 改行区切り     | 動く! |
| 5    | カスタム区切り | 動く! |
| 6    | 負の数の検証   | 動く! |
| 7    | 1000以上を無視 | 動く! |

- 小さな成功を積み重ねる → **フィードバック**と**自信**を得る
- 問題が起きても**直前の動く状態に戻せる**

---

# 演習3: 進め方

### ルール
- **1ステップずつ**実装する
- テストのTODOコメントを外し、実装する
- 各ステップ完了後に**リファクタリングを検討**する
- 引き続き**ペアプログラミング**で進める

### Step 5 のテスト例

```java
@Test
@DisplayName("カスタム区切り文字に対応する")
void shouldSupportCustomDelimiter() {
    assertEquals(3, calculator.add("//;\n1;2"));
    assertEquals(10, calculator.add("//|\n2|3|5"));
}
```

### コマンド
```bash
mvn test -Dtest=StringCalculatorTest
```

---

# 演習3: リファクタリングのヒント

### ステップが進むにつれて `add` メソッドが肥大化する → リファクタリング

#### Before（肥大化した例）
```java
public int add(String numbers) {
    // 空文字チェック
    // カスタム区切り文字の判定
    // 文字列の分割
    // 負の数の検証
    // 1000以上のフィルタ
    // 合計計算
    // ... すべてが1つのメソッドに
}
```

#### After（メソッド抽出後）
```java
public int add(String numbers) {
    if (numbers.isEmpty()) return 0;
    String[] parsed = parseDelimiters(numbers);
    validateNumbers(parsed);
    return sumNumbers(parsed);
}
```

---

# 演習3: 振り返りのポイント

### 体験した価値・原則
- **シンプルさ**: 各ステップでシンプルな設計を維持できたか
- **小さなステップ**: 機能を適切に分割できたか
- **変更の受け入れ**: 要件追加に柔軟に対応できたか

### 振り返り質問
- どの段階でリファクタリングの必要性を感じましたか？
- 段階的に実装することで、何が楽になりましたか？
- 一度に全機能を実装する場合と比べてどうでしたか？
- テストがあることで、リファクタリングの安心感は変わりましたか？

---

<!-- _class: title -->

# 第8部
## 演習4: BowlingGame / 継続的統合

---

# 演習4: BowlingGame - 課題説明

### ボーリングの基本ルール
- **10フレーム**制
- 各フレームで最大**2投**
- 10ピンすべて倒す → **ストライク** or **スペア**
- 最終（10th）フレームは特殊ルールあり

### 対象ファイル
- `BowlingGame.java` - 実装クラス
- `BowlingGameTest.java` - テストクラス

### XPフォーカス
- **Continuous Integration**: 頻繁にテストを実行し統合する
- **Testing**: 複雑なビジネスロジックを段階的にテストする
- **Small Releases**: 段階的に機能を追加する

---

# ボーリングスコアの基本

### 通常フレーム
- 2投の合計がそのフレームのスコア

### スペア（2投で10ピン）
- スコア = **10 + 次の1投のピン数**
- 例: [5, 5] → 次の投球が3 → フレームスコア = **13**

### ストライク（1投で10ピン）
- スコア = **10 + 次の2投のピン数の合計**
- 例: [10] → 次の2投が3, 4 → フレームスコア = **17**

### 特殊ケース
| ケース                               | スコア    |
| ------------------------------------ | --------- |
| パーフェクトゲーム（12回ストライク） | **300点** |
| すべてガター（20回0ピン）            | **0点**   |

---

# スコア計算の具体例

### 例: 通常ゲーム

| Frame | 1    | 2      | 3          | 4    | 5      | ... |
| ----- | ---- | ------ | ---------- | ---- | ------ | --- |
| Rolls | 3, 4 | 5, 5   | 10         | 2, 3 | 0, 0   | ... |
| Type  | 通常 | スペア | ストライク | 通常 | ガター | ... |
| Score | 7    | 20     | 15         | 5    | 0      | ... |
| Total | 7    | 27     | 42         | 47   | 47     | ... |

- フレーム2（スペア）: 10 + 次の1投(10) = **20**
- フレーム3（ストライク）: 10 + 次の2投(2+3) = **15**

---

# BowlingGameのデータ構造

```java
public class BowlingGame {
    private int[] rolls = new int[21];  // 最大21投
    private int currentRoll = 0;

    public void roll(int pins) { ... }  // 投球を記録
    public int score() { ... }          // 合計スコアを計算
}
```

### なぜ21投？
- 通常: 10フレーム x 2投 = 20投
- 最終フレームでストライクまたはスペア → **追加投球**あり
- 最大: 20 + 1 = **21投**

### スコア計算のアルゴリズム（疑似コード）
```
for each frame (1..10):
    if strike:    score += 10 + next 2 rolls
    else if spare: score += 10 + next 1 roll
    else:          score += sum of 2 rolls
```

---

# 継続的統合 (CI) のベストプラクティス

### 基本ルール
1. **頻繁にコミット**する（小さな変更を頻繁に）
2. コミット前に**全テストを実行**する
3. テストが**失敗したままコミットしない**
4. ビルドが壊れたら**最優先で修正**する

### 本演習での実践
```bash
mvn test -Dtest=BowlingGameTest  # 変更のたびに実行
mvn test                          # 全テスト確認
mvn test jacoco:report            # カバレッジ確認
```

### CIの効果
- 問題の**早期発見**
- 常に**動く状態**を維持
- チーム全体の**品質意識**向上

---

# 演習4: 進め方

### テストの実装順序（推奨）

| #   | テスト                      | 難易度 |
| --- | --------------------------- | ------ |
| 1   | すべてガターボール（0点）   | 基本   |
| 2   | すべて1ピン（20点）         | 基本   |
| 3   | 1つのスペアがある場合       | 中級   |
| 4   | 1つのストライクがある場合   | 中級   |
| 5   | パーフェクトゲーム（300点） | 上級   |
| 6   | すべてスペアの場合（150点） | 上級   |
| 7   | 最終フレームでストライク    | 上級   |
| 8   | 最終フレームでスペア        | 上級   |
| 9   | 複雑なスコアパターン        | 統合   |

**ルール**: ペアプロで進める / 各テスト後に全テスト実行（CI）/ 壊れたら即修正

---

# テストヘルパーの活用

### BowlingGameTest に用意されたヘルパーメソッド

```java
private void rollMany(int times, int pins) {
    for (int i = 0; i < times; i++) {
        game.roll(pins);
    }
}

private void rollSpare() {
    game.roll(5);
    game.roll(5);
}

private void rollStrike() {
    game.roll(10);
}
```

### 使用例
```java
rollMany(12, 10);                   // 12回ストライク
assertEquals(300, game.score());    // パーフェクトゲーム
```

---

# 演習4: 振り返りのポイント

### 体験した価値・原則
- **フィードバック**: テストによる品質確認
- **品質への責任**: 十分なテストカバレッジ
- **適応**: テスト結果に基づく改善

### 振り返り質問
- 複雑なビジネスロジックをテストする際に、どのような工夫をしましたか？
- テストを段階的に追加することの利点は何でしたか？
- テストが壊れたとき、どのように対処しましたか？
- CIの考え方を日常の開発にどう活かせますか？

---

<!-- _class: title -->

# 第9部
## 振り返りとディスカッション

---

# 価値の振り返り

### 各演習で体験した価値を振り返りましょう

| 価値               | 演習1 FizzBuzz | 演習2 Calculator | 演習3 StringCalc | 演習4 Bowling |
| ------------------ | :------------: | :--------------: | :--------------: | :-----------: |
| コミュニケーション |       -        |       ★★★        |        ★★        |      ★★       |
| シンプルさ         |      ★★★       |        ★★        |       ★★★        |       ★       |
| フィードバック     |      ★★★       |        ★★        |        ★★        |      ★★★      |
| 勇気               |       ★★       |        ★         |       ★★★        |      ★★       |
| 尊敬               |       ★        |       ★★★        |        ★★        |      ★★       |

### ディスカッション
- あなたにとって一番実感できた価値はどれですか？
- 一番難しいと感じた価値はどれですか？
- 普段の開発で最も不足していると感じる価値は？

---

# 原則の振り返り

### 小さなステップ (Baby Steps)
- 変更を小さく分割して進められましたか？
- 一度に多くのことをやろうとしていませんでしたか？
- 各ステップで動作確認ができましたか？

### 変更の受け入れ (Embracing Change)
- 要件の変更や追加を柔軟に受け入れられましたか？
- 既存のコードを変更することに抵抗はありませんでしたか？

### 品質への責任 (Quality Work)
- 高い品質基準を維持できましたか？
- テストカバレッジは十分でしたか？
- 「動けばいい」で終わらせていませんでしたか？

---

# ディスカッション課題 1

### 価値と原則の統合

XPの5つの価値と原則がどう相互作用するか考えてみましょう。

| 価値・原則 | TDDでの実践 | ペアプロでの実践 |
|-----------|------------|----------------|
| シンプルさ | 最小限のコードで実装 | - |
| フィードバック | テストによる即座の確認 | - |
| 勇気 | リファクタリングを恐れない | - |
| コミュニケーション | - | 積極的な対話 |
| 尊敬 | - | パートナーの意見を尊重 |
| 小さなステップ | Red-Green-Refactorサイクル | - |
| 多様性 | - | 異なる視点の活用 |

> **課題**: リファクタリング、継続的統合について、同様の分析をしてみましょう

---

# ディスカッション課題 2

### シナリオベースのディスカッション

以下のシナリオで、XPの価値をどう実践しますか？

**シナリオ1**: ペアプログラミング中に相手の提案が理解できない
- どのようにコミュニケーションを取りますか？

**シナリオ2**: 既存のコードが複雑で理解が困難
- 勇気を持ってどう対処しますか？

**シナリオ3**: 締切が迫っているがバグを発見した
- 品質への責任をどう果たしますか？

**シナリオ4**: チームメンバーの提案に疑問がある
- 尊敬を保ちながらどう議論しますか？

---

# ディスカッション課題 3

### 実プロジェクトへの導入を考える

XPの価値と原則を実際のプロジェクトにどう導入しますか？

### 考慮すべき課題
- 既存のチームメンバーとの**価値観の違い**
- 組織の**文化や制約**
- 時間やリソースの**制限**

### アクションプラン作成
1. **まず何から始めるか？**
   - 例: 小さなプロジェクトでTDDを試す
2. **どうやってチームに浸透させるか？**
   - 例: ペアプロの体験セッションを実施
3. **成功をどう測定するか？**
   - 例: バグ数の変化、デプロイ頻度
4. **失敗や抵抗にどう対処するか？**
   - 例: 小さな成功体験を積み重ねる

---

<!-- _class: title -->

# 第10部
## まとめ

---

# 学んだこと一覧

### XPの価値
| 価値               | キーワード                   |
| ------------------ | ---------------------------- |
| コミュニケーション | 対話、共有、透明性           |
| シンプルさ         | YAGNI、最小限、明確さ        |
| フィードバック     | テスト、CI、レビュー         |
| 勇気               | リファクタリング、正直、挑戦 |
| 尊敬               | 傾聴、建設的議論、多様性     |

### XPのプラクティス（本研修で体験したもの）
| プラクティス             | 体験した演習            |
| ------------------------ | ----------------------- |
| TDD (Red-Green-Refactor) | 演習1: FizzBuzz         |
| ペアプログラミング       | 演習2: Calculator       |
| リファクタリング         | 演習3: StringCalculator |
| Small Releases           | 演習3: StringCalculator |
| 継続的統合               | 演習4: BowlingGame      |

---

# 実践への橋渡し

### 明日からできること

**個人で始められること**
- テストを書いてからコードを書く（TDD）
- 小さなコミットを頻繁に行う
- リファクタリングの習慣をつける

**チームで始められること**
- ペアプログラミングの時間を設ける
- コードレビューの文化を育てる
- CIパイプラインを整備する

**心がけること**
- 完璧を目指さず、**小さく始める**
- 失敗を恐れず、**学びの機会**と捉える
- チームメンバーと**コミュニケーション**を取る

---

# 参考リンク

### 書籍
- Kent Beck "Extreme Programming Explained" (1st ed. 1999, 2nd ed. 2004)
- Robert C. Martin "Clean Code" (2008)
- Martin Fowler "Refactoring" (1st ed. 1999, 2nd ed. 2018)

### オンラインリソース
- Agile Alliance: agilealliance.org
- Martin Fowler's Blog: martinfowler.com
- Uncle Bob's Blog: blog.cleancoder.com

### 本研修のコマンドリファレンス
```bash
mvn test                           # 全テスト実行
mvn test -Dtest=クラス名             # 特定テスト実行
mvn test -Dtest=クラス名#メソッド名    # 個別テスト実行
mvn test jacoco:report             # カバレッジレポート
```

---

<!-- _class: title -->
<!-- _paginate: false -->

# お疲れ様でした

## XPの価値を実践に活かしていきましょう

**コミュニケーション / シンプルさ / フィードバック / 勇気 / 尊敬**
